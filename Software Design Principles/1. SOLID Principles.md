#সফটওয়্যার ইঞ্জিনিয়ারিংয়ের পাঁচটি মৌলিক নীতি হলো SOLID। এই নীতিগুলো অনুসরণ করলে কোড হয় Scalable (সহজে বড় করা যায়), Maintainable (সহজে মেরামত করা যায়) এবং Testable।

**1. S – Single Responsibility Principle (SRP)**
      মূল কথা : একটি ক্লাসের কেবল একটিই কাজ থাকা উচিত এবং পরিবর্তনের কারণও কেবল একটিই হওয়া উচিত।
       
       ব্যাখ্যা : একটি ক্লাস যেন "অলরাউন্ডার" না হয়। একটি নির্দিষ্ট কাজের দায়িত্ব কেবল একটি নির্দিষ্ট ক্লাসেরই থাকবে।
       
       সমস্যা (Problem) : ধরো তোমার Invoice ক্লাসের মধ্যেই ডাটাবেজে সেভ করা এবং পিডিএফ জেনারেট করার লজিক আছে। এখন যদিডাটাবেজের কানেকশন বদলাতে হয়, তবে তোমাকে এই পুরো ইনভয়েস ক্লাসটি এডিট করতে হবে, যা ঝুঁকিপূর্ণ।
       
       সমাধান (Solution) : ডাটাবেজ সেভের জন্য আলাদা InvoiceRepository এবং পিডিএফের জন্য InvoicePrinter ক্লাস বানানো।
       
       উদাহরণ: * Invoice ক্লাস: শুধু ইনভয়েসের ডাটা রাখবে। InvoiceDb ক্লাস: ডাটাবেজ সেভ করবে।


**2. O – Open/Closed Principle (OCP)**
        মূল কথা : সফটওয়্যার মডিউল নতুন ফিচারের জন্য খোলা (Open) থাকবে, কিন্তু কোড পরিবর্তনের জন্য বন্ধ (Closed) থাকবে।
        
        ব্যাখ্যা : নতুন ফিচার যোগ করতে হবে পুরনো কোড হাত না দিয়ে।
        
        সমস্যা (Problem) : যদি if-else ব্যবহার করে বিভিন্ন টাইপের ডিসকাউন্ট ক্যালকুলেট করো, তবে নতুন কোনো ডিসকাউন্ট যোগ করতে হলে তোমাকে পুরনো লজিক হাত দিতে হবে।
        
        সমাধান (Solution) : ইন্টারফেস বা অ্যাবস্ট্রাকশন ব্যবহার করা।
        
        উদাহরণ : তোমার বানানো Strategy Pattern নোটিফিকেশন সিস্টেম। সেখানে নতুন WhatsAppNotify যোগ করতে পুরনো কোনো ক্লাসে হাত দিতে হয়নি।



**3. L – Liskov Substitution Principle (LSP)**
        মূল কথা : প্যারেন্ট ক্লাসের অবজেক্টকে সরিয়ে যদি সেখানে চাইল্ড ক্লাসের অবজেক্ট রাখা হয়, তবে প্রোগ্রাম যেন ভেঙে না যায়।
        
        ব্যাখ্যা : চাইল্ড ক্লাস এমন কিছু করবে না যা প্যারেন্ট ক্লাসের মূল স্বভাবের বাইরে।
        
        সমস্যা (Problem) : ধরো তোমার Bird নামে ক্লাস আছে যার মেথড হলো Fly(). এখন তুমি Ostrich (উটপাখি) ক্লাস বানালে যা Bird কে ইনহেরিট করে। কিন্তু উটপাখি তো উড়তে পারে না! এখানে LSP নিয়ম ভঙ্গ হলো।
        
        সমাধান (Solution) : ইন্টারফেস আলাদা করা। যেমন: IFlyingBird এবং INonFlyingBird.
        
        উদাহরণ : সব পাখিই ডিম পাড়ে কিন্তু সব পাখি ওড়ে না। তাই Fly() মেথড কমন প্যারেন্ট ক্লাসে না রাখাই ভালো।



**4. I – Interface Segregation Principle (ISP)**
      মূল কথা : কোনো ক্লাসকে এমন মেথড ইমপ্লিমেন্ট করতে বাধ্য করা যাবে না যা সে ব্যবহার করে না।

      ব্যাখ্যা : বড় বা বিশাল ইন্টারফেসের চেয়ে ছোট ছোট অনেকগুলো ইন্টারফেস ভালো।
      
      সমস্যা (Problem) : একটি IWorker ইন্টারফেসে Work() এবং Eat() মেথড আছে। এখন তুমি একটি Robot ক্লাস বানালে যা IWorker ইমপ্লিমেন্ট করে। রোবট তো খায় না! কিন্তু ইন্টারফেসের কারণে তাকে Eat() মেথডটি জোর করে লিখতে হচ্ছে।
      
      সমাধান (Solution): ইন্টারফেস আলাদা করা—IWorkable এবং IEatable.
      
      উদাহরণ : রোবট শুধু IWorkable ইন্টারফেস ব্যবহার করবে।



**5. D – Dependency Inversion Principle (DIP)**
        মূল কথা : হাই-লেভেল মডিউল কখনোই লো-লেভেল মডিউলের ওপর সরাসরি নির্ভর করবে না; উভয়েই অ্যাবস্ট্রাকশনের (ইন্টারফেস) ওপর নির্ভর করবে।
        
        ব্যাখ্যা : ক্লাসগুলোর মধ্যে সরাসরি সম্পর্ক না রেখে মাঝখানে একটি ইন্টারফেস রাখা।
        
        সমস্যা (Problem) : তোমার OrderManager ক্লাস সরাসরি GmailService ক্লাসের অবজেক্ট ব্যবহার করছে। কালকে যদি OutlookService ব্যবহার করতে হয়, তবে পুরো OrderManager এডিট করতে হবে।
        
        সমাধান (Solution) : মাঝখানে একটি IEmailProvider ইন্টারফেস ব্যবহার করা।
        
        উদাহরণ : তোমার কোডের NotifyContext ক্লাসটি সরাসরি EmailNotify এর ওপর নির্ভর না করে INotify ইন্টারফেসের ওপর নির্ভর করছে। এটাই হলো Dependency Inversion।
